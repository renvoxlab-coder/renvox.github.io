<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RENVOX Crypto Radar â€” Binance v4.3 - Filtrado TÃ¡ctico</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
Â  body{background:#0b0e12;color:#e2e8f0;font-family:Inter,Arial,sans-serif}
Â  a.btn{background:#16a34a;color:#fff;padding:.25rem .6rem;border-radius:.5rem;font-weight:600;transition:all .2s}
Â  a.btn:hover{background:#22c55e}
Â  th,td{text-align:right;padding:.55rem .75rem}
Â  th:first-child,td:first-child{text-align:left}
Â  .muted{color:#94a3b8}
Â  .cat-header{background:#1f2937;color:#93c5fd;font-weight:700;cursor:pointer;user-select:none}
Â  .cat-header .arrow{transition:transform .2s}
Â  .collapsed .arrow{transform:rotate(-90deg)}
Â  tr.highlight-green{background:#064e3b!important}
Â  tr.highlight-blue{background:#0c4a6e!important}
Â  tr.highlight-yellow{background:#78350f!important}
Â  .chip{padding:.15rem .45rem;border-radius:.5rem}
</style>
</head>
<body class="p-6">
<h1 class="text-3xl font-bold text-green-400 mb-2 text-center">RENVOX Crypto Radar â€” Binance v4.3</h1>
<p class="text-gray-400 text-center mb-6">
RSI Â· EMA20/50 Â· Fibonacci (**21d**) Â· ğŸ¯ Targets 1.272/1.618.<br/>
**FILTROS ACTIVOS:** Upside **$10\%$ a $40\%$** **Y** RR **$\ge 2.0x$** (para al menos T1 o T2).<br/>
Fuente principal: Binance klines 1h â€¢ Fallback: CoinGecko. Refresca cada 1 hora.
</p>

<div class="overflow-x-auto border border-gray-700 rounded-xl">
Â  <table class="w-full text-xs md:text-sm" id="table">
Â  Â  <thead class="bg-gray-800 text-gray-300">
Â  Â  Â  <tr>
Â  Â  Â  Â  <th>Token</th>
Â  Â  Â  Â  <th>Precio</th>
Â  Â  Â  Â  <th>RSI14</th>
Â  Â  Â  Â  <th>EMA20/50</th>
Â  Â  Â  Â  <th>Zona Fibo</th>
Â  Â  Â  Â  <th>SeÃ±al</th>
Â  Â  Â  Â  <th>Riesgo</th>
Â  Â  Â  Â  <th>ğŸ¯ Targets</th>
Â  Â  Â  Â  <th>ğŸ“ˆ Upside</th>
Â  Â  Â  Â  <th>ğŸ›Ÿ Stop</th>
Â  Â  Â  Â  <th>âš–ï¸ RR</th>
Â  Â  Â  Â  <th style="text-align:center">Spark</th>
Â  Â  Â  Â  <th>GrÃ¡fico</th>
Â  Â  Â  </tr>
Â  Â  </thead>
Â  Â  <tbody id="rows" class="bg-gray-900"></tbody>
Â  </table>
</div>

<script>
/* =============== CONFIG =============== */
const REFRESH_INTERVAL = 3600000; // 1h
const CACHE_KEY = "renvox_v43_rows";

/* CategorÃ­as y tokens (pares USDT) */
const CATEGORIES = {
Â  "ğŸ¤– Inteligencia Artificial": ["RNDRUSDT","FETUSDT","GRTUSDT","OCEANUSDT","AGIXUSDT","TAOUSDT"],
Â  "âš¡ EnergÃ­a / BaterÃ­as / IoT": ["NEOUSDT","IOTAUSDT","ICPUSDT","NKNUSDT","POWRUSDT","EWTUSDT"],
Â  "ğŸ—ï¸ Infraestructura / OrÃ¡culos": ["LINKUSDT","INJUSDT","ARBUSDT","OPUSDT","AVAXUSDT","ATOMUSDT"],
Â  "ğŸ’° Mainstream": ["BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","ADAUSDT","DOTUSDT"],
Â  "ğŸŒ Web3 emergentes": ["TIAUSDT","PYTHUSDT","ALTUSDT","SEIUSDT","JTOUSDT"]
};

/* Mapeo a IDs de CoinGecko para fallback */
const CG_IDS = {
Â  RNDR:"render-token", FET:"fetch-ai", GRT:"the-graph", OCEAN:"ocean-protocol", AGIX:"singularitynet", TAO:"bittensor",
Â  NEO:"neo", IOTA:"iota", ICP:"internet-computer", NKN:"nkn", POWR:"power-ledger", EWT:"energy-web-token",
Â  LINK:"chainlink", INJ:"injective-protocol", ARB:"arbitrum", OP:"optimism", AVAX:"avalanche-2", ATOM:"cosmos",
Â  BTC:"bitcoin", ETH:"ethereum", SOL:"solana", BNB:"binancecoin", ADA:"cardano", DOT:"polkadot",
Â  TIA:"celestia", PYTH:"pyth-network", ALT:"altlayer", SEI:"sei-network", JTO:"jito"
};

/* =============== UTILS =============== */
const fmt=(n,fd=2)=>Number.isFinite(n)?n.toLocaleString(undefined,{maximumFractionDigits:fd}):"-";
const pct=(v)=>Number.isFinite(v)?(v>=0?`+${fmt(v,2)}%`:`${fmt(v,2)}%`):"-";
function average(arr){if(!arr.length) return 0; return arr.reduce((a,b)=>a+b,0)/arr.length;}

/* EMA & RSI */
function ema(values,span){
Â  const k=2/(span+1); let prev=values[0], out=[prev];
Â  for(let i=1;i<values.length;i++){prev=values[i]*k + prev*(1-k); out.push(prev);}
Â  return out;
}
function rsi(values,period=14){
Â  let g=0,l=0;
Â  for(let i=1;i<=period;i++){const d=values[i]-values[i-1]; if(d>=0) g+=d; else l-=d;}
Â  let ag=g/period, al=l/period;
Â  for(let i=period+1;i<values.length;i++){
Â  Â  const d=values[i]-values[i-1], gain=Math.max(d,0), loss=Math.max(-d,0);
Â  Â  ag=(ag*(period-1)+gain)/period; al=(al*(period-1)+loss)/period;
Â  }
Â  const rs = al===0?100:ag/al;
Â  return 100-(100/(1+rs));
}

/* Sparkline simple (Ãºltimos 7 dÃ­as ~168 datos 1h) */
function sparkSVG(series,w=86,h=26,m=2){
Â  const data = series.slice(-168);
Â  if(data.length<2) return "";
Â  const min=Math.min(...data), max=Math.max(...data), rng=(max-min)||1;
Â  const W=w-2*m,H=h-2*m;
Â  const pts = data.map((v,i)=>{
Â  Â  const x=m + i*(W/(data.length-1));
Â  Â  const y=m + H - ((v-min)/rng)*H;
Â  Â  return `${x.toFixed(1)},${y.toFixed(1)}`;
Â  }).join(" ");
Â  const up = data[data.length-1]>=data[0];
Â  const stroke = up ? "#22c55e" : "#60a5fa";
Â  return `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
Â  Â  <polyline fill="none" stroke="${stroke}" stroke-width="1.5" points="${pts}" />
Â  </svg>`;
}

/* SeÃ±al, riesgo y ranking */
function riskBadge(rsi,emaGap){
Â  if(rsi<45 && emaGap<2) return {txt:"ğŸŸ© Bajo", cls:"text-green-400"};
Â  if(rsi>65 || emaGap>4)Â  return {txt:"ğŸŸ¥ Alto", cls:"text-red-400"};
Â  return {txt:"ğŸŸ¨ Medio", cls:"text-yellow-400"};
}
function signalFrom(price, max14, inZone, trendUp, rsi){
Â  if(inZone && trendUp && rsi>=50 && rsi<=65) return {txt:"ğŸŸ¢ Pullback", color:"text-green-400", row:"highlight-green"};
Â  if(inZone && rsi>=40 && rsi<=70)Â  Â  Â  Â  Â  Â return {txt:"ğŸŸ¡ Pullback leve", color:"text-yellow-400", row:"highlight-yellow"};
Â  if(price > max14 && trendUp && rsi>60)Â  Â  Â return {txt:"ğŸ”µ Breakout", color:"text-cyan-400", row:"highlight-blue"};
Â  if(rsi>70)Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return {txt:"ğŸ”´ Caliente", color:"text-red-400", row:""};
Â  return {txt:"âšª Mirar", color:"text-gray-300", row:""};
}
function rankScore(sigTxt, riskTxt, up1, volScore){
Â  let s=0;
Â  if(sigTxt.includes("Pullback")) s+=5;
Â  if(sigTxt.includes("leve"))Â  Â  Â s+=3;
Â  if(sigTxt.includes("Breakout")) s+=2;
Â  if(riskTxt.includes("Bajo"))Â  Â  s+=1;
Â  if(up1>0)Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â s+=1;
Â  return s + (volScore||0); // empujoncito por volumen
}

/* TradingView link */
function tvLink(symbol){const base=symbol.replace("USDT",""); return `https://www.tradingview.com/symbols/${base}USDT/`;}

/* =============== DATA FETCHERS =============== */
async function fetchBinance(symbol){
Â  const url=`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=500`;
Â  const r=await fetch(url);
Â  if(!r.ok) throw new Error(`Binance HTTP ${r.status}`);
Â  const data=await r.json();
Â  if(!Array.isArray(data)||!data.length) throw new Error("Binance data vacÃ­o");
Â  const closes = data.map(k=>parseFloat(k[4]));
Â  const volsÂ  Â = data.map(k=>parseFloat(k[5]||0)); // base asset volume
Â  return {closes, volumeHint: average(vols.slice(-168))};
}
async function fetchCoinGecko(symbol){
Â  const base = symbol.replace("USDT","");
Â  const id = CG_IDS[base];
Â  if(!id) throw new Error("Sin mapeo CoinGecko para "+base);
Â  const url=`https://www.coingecko.com/api/v3/coins/${id}/market_chart?vs_currency=usd&days=21&interval=hourly`;
Â  const r=await fetch(url);
Â  if(!r.ok) throw new Error(`CG HTTP ${r.status}`);
Â  const j=await r.json();
Â  if(!j.prices || !j.prices.length) throw new Error("CG data vacÃ­o");
Â  const closes = j.prices.map(p=>p[1]);
Â  return {closes, volumeHint: 0}; // CG: sin volumen por vela en este endpoint
}


/* =============== CORE ANALYSIS (FILTROS RR >= 2.0x y Upside 10-40%) =============== */
async function analyze(symbol){
Â  let closes, volumeHint=0;
Â  try { ({closes,volumeHint} = await fetchBinance(symbol)); }
Â  catch(e){
Â  Â  console.warn(symbol,"Binance fallo -> CG fallback:",e?.message||e);
Â  Â  ({closes,volumeHint} = await fetchCoinGecko(symbol));
Â  }
Â  if(!closes || closes.length<60) throw new Error("Serie insuficiente");

Â  const price = closes.at(-1);
Â  const ema20 = ema(closes,20).at(-1);
Â  const ema50 = ema(closes,50).at(-1);
Â  const rsi14 = rsi(closes,14);

Â  // Swing 21d (500 velas 1h) - Ajustado para mejor rango Fibo
Â  const last500 = closes.slice(-500);
Â  const max14 = Math.max(...last500);
Â  const min14 = Math.min(...last500);
Â  const range = (max14 - min14) || 1;

Â  // Retrocesos (zona compra) + Extensiones (targets)
Â  const fib50 = min14 + 0.5*range;
Â  const fib618 = min14 + 0.618*range;
Â  const inZone = price>=fib50 && price<=fib618;
Â  const t1272 = min14 + 1.272*range;
Â  const t1618 = min14 + 1.618*range;

Â  // SeÃ±al, riesgo, ranking
Â  const trendUp = ema20 > ema50;
Â  const sig = signalFrom(price,max14,inZone,trendUp,rsi14);
Â  const emaGap = Math.abs(ema20-ema50)/((ema20+ema50)/2)*100;
Â  const risk = riskBadge(rsi14,emaGap);
Â  const up1 = ((t1272 - price)/price)*100;
Â  const up2 = ((t1618 - price)/price)*100;
Â  const stop = Math.min(fib618, ema50) * 0.995; // colchÃ³n -0.5%
Â  const riskAbs = Math.max(price - stop, 0.0000001);
Â  const rr1 = (t1272 - price)/riskAbs;
Â  const rr2 = (t1618 - price)/riskAbs;


Â  // === FILTRO 1: UPSIDE (10% - 40%) ===
Â  const MIN_UPSIDE = 10;
Â  const MAX_UPSIDE = 40;

Â  // El token pasa si T1 o T2 cumplen el rango de Upside
Â  const meetsUpside = (up1 >= MIN_UPSIDE && up1 <= MAX_UPSIDE) || (up2 >= MIN_UPSIDE && up2 <= MAX_UPSIDE);

Â  if (!meetsUpside) {
Â  Â  throw new Error(`Filtro: Upside ${pct(up1)}/${pct(up2)} fuera de rango ${MIN_UPSIDE}%-${MAX_UPSIDE}%`);
Â  }
Â  
Â  // === FILTRO 2: RIESGO/RECOMPENSA (RR >= 2.0x) ===
Â  const MIN_RR = 2.0;

Â  // El token pasa si T1 o T2 tienen un RR aceptable
Â  const meetsRR = rr1 >= MIN_RR || rr2 >= MIN_RR;

Â  if (!meetsRR) {
Â  Â  throw new Error(`Filtro: RR T1=${fmt(rr1)}x / T2=${fmt(rr2)}x es menor a ${MIN_RR}x`);
Â  }


Â  // Ranking simple ponderando volumen
Â  const volScore = volumeHint ? Math.tanh(volumeHint) : 0; // normaliza 0..1
Â  const rank = rankScore(sig.txt, risk.txt, up1, volScore);

Â  return {
Â  Â  symbol, price, rsi14, ema20, ema50, fib50, fib618, t1272, t1618,
Â  Â  up1, up2, stop, rr1, rr2, closes, signal:sig.txt, signalColor:sig.color,
Â  Â  rowClass:sig.row, risk, rank
Â  };
}

/* =============== RENDER (MODIFICADO para manejar los filtros de Upside y RR) =============== */
function rowHTML(o){
Â  return `
Â  <tr class="border-b border-gray-800 ${o.rowClass}">
Â  Â  <td>${o.symbol}</td>
Â  Â  <td>$${fmt(o.price)}</td>
Â  Â  <td>${fmt(o.rsi14)}</td>
Â  Â  <td>${fmt(o.ema20)} / ${fmt(o.ema50)}</td>
Â  Â  <td>${fmt(o.fib50)}â€“${fmt(o.fib618)}</td>
Â  Â  <td class="${o.signalColor} font-bold">${o.signal}</td>
Â  Â  <td class="${o.risk.cls} font-semibold">${o.risk.txt}</td>
Â  Â  <td>
Â  Â  Â  <div>${fmt(o.t1272)} <span class="muted">(1.272)</span></div>
Â  Â  Â  <div>${fmt(o.t1618)} <span class="muted">(1.618)</span></div>
Â  Â  </td>
Â  Â  <td>
Â  Â  Â  <div class="${o.up1>0?'text-green-400':'text-gray-400'}">${pct(o.up1)}</div>
Â  Â  Â  <div class="${o.up2>0?'text-green-400':'text-gray-400'}">${pct(o.up2)}</div>
Â  Â  </td>
Â  Â  <td>$${fmt(o.stop)}</td>
Â  Â  <td>
Â  Â  Â  <div class="${o.rr1>=2?'text-green-400':(o.rr1>=1?'text-yellow-400':'text-red-400')}">T1: ${fmt(o.rr1,2)}x</div>
Â  Â  Â  <div class="${o.rr2>=2?'text-green-400':(o.rr2>=1?'text-yellow-400':'text-red-400')}">T2: ${fmt(o.rr2,2)}x</div>
Â  Â  </td>
Â  Â  <td style="text-align:center">${sparkSVG(o.closes)}</td>
Â  Â  <td><a class="btn" target="_blank" href="${tvLink(o.symbol)}">Ver</a></td>
Â  </tr>`;
}

function catHeaderHTML(cat, open=true){
Â  return `
Â  <tr class="cat-header ${open?'':'collapsed'}" data-cat="${cat}">
Â  Â  <td colspan="13"><span class="arrow">â–¾</span> ${cat}</td>
Â  </tr>`;
}

async function render(){
Â  const tbody = document.getElementById("rows");

Â  // pintar cache si existe
Â  const cached = localStorage.getItem(CACHE_KEY);
Â  if(cached) tbody.innerHTML = cached;
Â  if(!cached) tbody.innerHTML = `<tr><td colspan="13" class="p-4 text-gray-400">Cargando datos...</td></tr>`;

Â  let html = "";

Â  for (const [cat, tokens] of Object.entries(CATEGORIES)) {
Â  Â  html += catHeaderHTML(cat, true);
Â  Â  // fetch en paralelo por categorÃ­a
Â  Â  const results = await Promise.allSettled(tokens.map(analyze));

Â  Â  // FILTRAR: Solo tomamos las que cumplen el criterio (status="fulfilled")
Â  Â  const fulfilledRows = results
Â  Â  Â  .filter(r => r.status==="fulfilled")
Â  Â  Â  .map(r => r.value)
Â  Â  Â  .sort((a,b)=> b.rank - a.rank);

Â  Â  const rows = fulfilledRows
Â  Â  Â  .map(rowHTML)
Â  Â  Â  .join("");

Â  Â  // Mensajes: Errores graves de API/datos y resumen de tokens filtrados
Â  Â  const apiErrors = results
Â  Â  Â  .filter(r => r.status==="rejected" && (String(r.reason).includes("HTTP") || String(r.reason).includes("data vacÃ­o") || String(r.reason).includes("insuficiente")))
Â  Â  Â  .map((r)=> `<tr class="border-b border-gray-800 text-red-400"><td colspan="13">Error de datos: ${r.reason?.message || "Desconocido"}</td></tr>`)
Â  Â  Â  .join("");

Â  Â  // Contamos los tokens filtrados por la regla de Upside Y RR
Â  Â  const filteredTokensCount = results.filter(r => r.status==="rejected" && String(r.reason).includes("Filtro:")).length;

Â  Â  const filterSummary = filteredTokensCount > 0
Â  Â  Â  ? `<tr class="border-b border-gray-800 text-yellow-400"><td colspan="13">${filteredTokensCount} tokens filtrados (No cumplen Upside $10\%-40\%$ **o** RR $\ge 2.0x$).</td></tr>`
Â  Â  Â  : "";

Â  Â  html += rows + filterSummary + apiErrors;
Â  }

Â  tbody.innerHTML = html;
Â  localStorage.setItem(CACHE_KEY, html);
Â  attachCollapsers();
Â  console.log("âœ… ActualizaciÃ³n:", new Date().toLocaleTimeString());
Â  setTimeout(render, REFRESH_INTERVAL);
}

/* Colapsar/expandir categorÃ­as */
function attachCollapsers(){
Â  const tbody = document.getElementById("rows");
Â  const headers = tbody.querySelectorAll(".cat-header");
Â  headers.forEach(h=>{
Â  Â  const cat = h.getAttribute("data-cat");
Â  Â  h.addEventListener("click", ()=>{
Â  Â  Â  let row = h.nextElementSibling;
Â  Â  Â  const collapsed = h.classList.toggle("collapsed");
Â  Â  Â  while(row && !row.classList.contains("cat-header")){
Â  Â  Â  Â  row.style.display = collapsed ? "none" : "";
Â  Â  Â  Â  row = row.nextElementSibling;
Â  Â  Â  }
Â  Â  });
Â  Â  // SÃ­mbolo de flecha correcto
Â  Â  const arrow = h.querySelector(".arrow");
Â  Â  if(arrow){ arrow.textContent = "â–¾"; }
Â  });
}

/* start */
render();
</script>

<p class="text-xs text-gray-500 mt-4 text-center">
v4.3 (Final) â€” Pares activos y lÃ­quidos, Binance 1h con fallback CoinGecko, ranking por
