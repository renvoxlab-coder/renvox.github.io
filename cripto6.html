<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RENVOX Crypto Radar â€” Binance v6.0 (Filtro Upside & RR Â· 21d Â· Ranking Vol)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body{background:#0b0e12;color:#e2e8f0;font-family:Inter,Arial,sans-serif}
  a.btn{background:#16a34a;color:#fff;padding:.25rem .6rem;border-radius:.5rem;font-weight:600;transition:all .2s}
  a.btn:hover{background:#22c55e}
  th,td{text-align:right;padding:.55rem .75rem}
  th:first-child,td:first-child{text-align:left}
  .muted{color:#94a3b8}
  .cat-header{background:#1f2937;color:#93c5fd;font-weight:700;cursor:pointer;user-select:none}
  .cat-header .arrow{transition:transform .2s}
  .collapsed .arrow{transform:rotate(-90deg)}
  tr.highlight-green{background:#064e3b!important}
  tr.highlight-blue{background:#0c4a6e!important}
  tr.highlight-yellow{background:#78350f!important}
</style>
</head>
<body class="p-6">
<h1 class="text-3xl font-bold text-green-400 mb-2 text-center">RENVOX Crypto Radar â€” Binance v6.0</h1>
<p class="text-gray-400 text-center mb-6">
RSI Â· EMA20/50 Â· Fibonacci <b>(21d)</b> Â· ğŸ¯ Targets 1.272/1.618 Â· ğŸ›Ÿ Stop Â· âš–ï¸ RR Â· Sparkline 7d Â· categorÃ­as colapsables.<br/>
<b>FILTROS ACTIVOS:</b> Upside <b>10â€“40%</b> (T1 o T2) <b>Y</b> RR <b>â‰¥ 2.0x</b> (T1 o T2). &nbsp; Fuente: Binance 1h Â· Fallback CoinGecko Â· Refresca cada 1h.
</p>

<div class="overflow-x-auto border border-gray-700 rounded-xl">
  <table class="w-full text-xs md:text-sm" id="table">
    <thead class="bg-gray-800 text-gray-300">
      <tr>
        <th>Token</th>
        <th>Precio</th>
        <th>RSI14</th>
        <th>EMA20/50</th>
        <th>Zona Fibo</th>
        <th>SeÃ±al</th>
        <th>Riesgo</th>
        <th>ğŸ¯ Targets</th>
        <th>ğŸ“ˆ Upside</th>
        <th>ğŸ›Ÿ Stop</th>
        <th>âš–ï¸ RR</th>
        <th style="text-align:center">Spark</th>
        <th>GrÃ¡fico</th>
      </tr>
    </thead>
    <tbody id="rows" class="bg-gray-900"></tbody>
  </table>
</div>

<script>
/* =============== CONFIG =============== */
const REFRESH_INTERVAL = 3600000; // 1h
const CACHE_KEY = "renvox_v60_rows";

/* Filtros tÃ¡cticos */
const MIN_UPSIDE = 10;   // %
const MAX_UPSIDE = 40;   // %
const MIN_RR      = 2.0; // x

/* CategorÃ­as y tokens (pares USDT) */
const CATEGORIES = {
  "ğŸ¤– Inteligencia Artificial": ["RNDRUSDT","FETUSDT","GRTUSDT","OCEANUSDT","AGIXUSDT","TAOUSDT"],
  "âš¡ EnergÃ­a / BaterÃ­as / IoT": ["NEOUSDT","IOTAUSDT","ICPUSDT","NKNUSDT","POWRUSDT","EWTUSDT"],
  "ğŸ—ï¸ Infraestructura / OrÃ¡culos": ["LINKUSDT","INJUSDT","ARBUSDT","OPUSDT","AVAXUSDT","ATOMUSDT"],
  "ğŸ’° Mainstream": ["BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","ADAUSDT","DOTUSDT"],
  "ğŸŒ Web3 emergentes": ["TIAUSDT","PYTHUSDT","ALTUSDT","SEIUSDT","JTOUSDT"]
};

/* Mapeo a IDs de CoinGecko para fallback */
const CG_IDS = {
  RNDR:"render-token", FET:"fetch-ai", GRT:"the-graph", OCEAN:"ocean-protocol", AGIX:"singularitynet", TAO:"bittensor",
  NEO:"neo", IOTA:"iota", ICP:"internet-computer", NKN:"nkn", POWR:"power-ledger", EWT:"energy-web-token",
  LINK:"chainlink", INJ:"injective-protocol", ARB:"arbitrum", OP:"optimism", AVAX:"avalanche-2", ATOM:"cosmos",
  BTC:"bitcoin", ETH:"ethereum", SOL:"solana", BNB:"binancecoin", ADA:"cardano", DOT:"polkadot",
  TIA:"celestia", PYTH:"pyth-network", ALT:"altlayer", SEI:"sei-network", JTO:"jito"
};

/* =============== UTILS =============== */
const fmt=(n,fd=2)=>Number.isFinite(n)?n.toLocaleString(undefined,{maximumFractionDigits:fd}):"-";
const pct=(v)=>Number.isFinite(v)?(v>=0?`+${fmt(v,2)}%`:`${fmt(v,2)}%`):"-";
function average(arr){if(!arr.length) return 0; return arr.reduce((a,b)=>a+b,0)/arr.length;}

/* EMA & RSI */
function ema(values,span){
  const k=2/(span+1); let prev=values[0], out=[prev];
  for(let i=1;i<values.length;i++){prev=values[i]*k + prev*(1-k); out.push(prev);}
  return out;
}
function rsi(values,period=14){
  let g=0,l=0;
  for(let i=1;i<=period;i++){const d=values[i]-values[i-1]; if(d>=0) g+=d; else l-=d;}
  let ag=g/period, al=l/period;
  for(let i=period+1;i<values.length;i++){
    const d=values[i]-values[i-1], gain=Math.max(d,0), loss=Math.max(-d,0);
    ag=(ag*(period-1)+gain)/period; al=(al*(period-1)+loss)/period;
  }
  const rs = al===0?100:ag/al;
  return 100-(100/(1+rs));
}

/* Sparkline simple (Ãºltimos 7 dÃ­as ~168 datos 1h) */
function sparkSVG(series,w=86,h=26,m=2){
  const data = series.slice(-168);
  if(data.length<2) return "";
  const min=Math.min(...data), max=Math.max(...data), rng=(max-min)||1;
  const W=w-2*m,H=h-2*m;
  const pts = data.map((v,i)=>{
    const x=m + i*(W/(data.length-1));
    const y=m + H - ((v-min)/rng)*H;
    return `${x.toFixed(1)},${y.toFixed(1)}`;
  }).join(" ");
  const up = data[data.length-1]>=data[0];
  const stroke = up ? "#22c55e" : "#60a5fa";
  return `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
    <polyline fill="none" stroke="${stroke}" stroke-width="1.5" points="${pts}" />
  </svg>`;
}

/* SeÃ±al, riesgo y ranking */
function riskBadge(rsi,emaGap){
  if(rsi<45 && emaGap<2) return {txt:"ğŸŸ© Bajo", cls:"text-green-400"};
  if(rsi>65 || emaGap>4)  return {txt:"ğŸŸ¥ Alto", cls:"text-red-400"};
  return {txt:"ğŸŸ¨ Medio", cls:"text-yellow-400"};
}
function signalFrom(price, max14, inZone, trendUp, rsi){
  if(inZone && trendUp && rsi>=50 && rsi<=65) return {txt:"ğŸŸ¢ Pullback", color:"text-green-400", row:"highlight-green"};
  if(inZone && rsi>=40 && rsi<=70)           return {txt:"ğŸŸ¡ Pullback leve", color:"text-yellow-400", row:"highlight-yellow"};
  if(price > max14 && trendUp && rsi>60)     return {txt:"ğŸ”µ Breakout", color:"text-cyan-400", row:"highlight-blue"};
  if(rsi>70)                                  return {txt:"ğŸ”´ Caliente", color:"text-red-400", row:""};
  return {txt:"âšª Mirar", color:"text-gray-300", row:""};
}
/* ranking: seÃ±al + riesgo + upside + volumen */
function rankScore(sigTxt, riskTxt, up1, volScore){
  let s=0;
  if(sigTxt.includes("Pullback")) s+=5;
  if(sigTxt.includes("leve"))     s+=3;
  if(sigTxt.includes("Breakout")) s+=2;
  if(riskTxt.includes("Bajo"))    s+=1;
  if(up1>0)                       s+=1;
  return s + (volScore||0);
}

/* TradingView link */
function tvLink(symbol){const base=symbol.replace("USDT",""); return `https://www.tradingview.com/symbols/${base}USDT/`;}

/* =============== DATA FETCHERS =============== */
async function fetchBinance(symbol){
  const url=`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=500`;
  const r=await fetch(url);
  if(!r.ok) throw new Error(`Binance HTTP ${r.status}`);
  const data=await r.json();
  if(!Array.isArray(data)||!data.length) throw new Error("Binance data vacÃ­o");
  const closes = data.map(k=>parseFloat(k[4]));
  const vols   = data.map(k=>parseFloat(k[5]||0)); // base asset volume
  return {closes, volumeHint: average(vols.slice(-168))};
}
async function fetchCoinGecko(symbol){
  const base = symbol.replace("USDT","");
  const id = CG_IDS[base];
  if(!id) throw new Error("Sin mapeo CoinGecko para "+base);
  const url=`https://www.coingecko.com/api/v3/coins/${id}/market_chart?vs_currency=usd&days=21&interval=hourly`;
  const r=await fetch(url);
  if(!r.ok) throw new Error(`CG HTTP ${r.status}`);
  const j=await r.json();
  if(!j.prices || !j.prices.length) throw new Error("CG data vacÃ­o");
  const closes = j.prices.map(p=>p[1]);
  return {closes, volumeHint: 0}; // CG no trae volumen por vela en este endpoint
}

/* =============== CORE ANALYSIS con filtros Upside & RR (21d) =============== */
async function analyze(symbol){
  let closes, volumeHint=0;
  try { ({closes,volumeHint} = await fetchBinance(symbol)); }
  catch(e){
    console.warn(symbol,"Binance fallo -> CG fallback:",e?.message||e);
    ({closes,volumeHint} = await fetchCoinGecko(symbol));
  }
  if(!closes || closes.length<60) throw new Error("Serie insuficiente");

  const price = closes.at(-1);
  const ema20 = ema(closes,20).at(-1);
  const ema50 = ema(closes,50).at(-1);
  const rsi14 = rsi(closes,14);

  // Swing 21d (â‰ˆ500 velas 1h)
  const last500 = closes.slice(-500);
  const max14 = Math.max(...last500);
  const min14 = Math.min(...last500);
  const range = (max14 - min14) || 1;

  // Retrocesos (zona compra) + Extensiones (targets)
  const fib50 = min14 + 0.5*range;
  const fib618 = min14 + 0.618*range;
  const inZone = price>=fib50 && price<=fib618;
  const t1272 = min14 + 1.272*range;
  const t1618 = min14 + 1.618*range;

  // SeÃ±al, riesgo y mÃ©tricas
  const trendUp = ema20 > ema50;
  const sig = signalFrom(price,max14,inZone,trendUp,rsi14);
  const emaGap = Math.abs(ema20-ema50)/((ema20+ema50)/2)*100;
  const risk = riskBadge(rsi14,emaGap);

  const up1 = ((t1272 - price)/price)*100;
  const up2 = ((t1618 - price)/price)*100;

  // Stop sugerido y RR
  const stop = Math.min(fib618, ema50) * 0.995; // colchÃ³n -0.5%
  const riskAbs = Math.max(price - stop, 0.0000001);
  const rr1 = (t1272 - price)/riskAbs;
  const rr2 = (t1618 - price)/riskAbs;

  // === FILTRO: Upside (10â€“40%) ===
  const meetsUpside = (up1 >= MIN_UPSIDE && up1 <= MAX_UPSIDE) || (up2 >= MIN_UPSIDE && up2 <= MAX_UPSIDE);
  if (!meetsUpside) throw new Error(`Filtro: Upside ${pct(up1)}/${pct(up2)} fuera de ${MIN_UPSIDE}â€“${MAX_UPSIDE}%`);

  // === FILTRO: RR â‰¥ 2.0x (T1 o T2) ===
  const meetsRR = rr1 >= MIN_RR || rr2 >= MIN_RR;
  if (!meetsRR) throw new Error(`Filtro: RR T1=${fmt(rr1)}x / T2=${fmt(rr2)}x < ${MIN_RR}x`);

  // Ranking con volumen (liquidez reciente)
  const volScore = volumeHint ? Math.tanh(volumeHint) : 0;
  const rank = rankScore(sig.txt, risk.txt, up1, volScore);

  return {
    symbol, price, rsi14, ema20, ema50, fib50, fib618, t1272, t1618,
    up1, up2, stop, rr1, rr2, closes, signal:sig.txt, signalColor:sig.color,
    rowClass:sig.row, risk, rank
  };
}

/* =============== RENDER con mensajes de depuraciÃ³n =============== */
function rowHTML(o){
  return `
  <tr class="border-b border-gray-800 ${o.rowClass}">
    <td>${o.symbol}</td>
    <td>$${fmt(o.price)}</td>
    <td>${fmt(o.rsi14)}</td>
    <td>${fmt(o.ema20)} / ${fmt(o.ema50)}</td>
    <td>${fmt(o.fib50)}â€“${fmt(o.fib618)}</td>
    <td class="${o.signalColor} font-bold">${o.signal}</td>
    <td class="${o.risk.cls} font-semibold">${o.risk.txt}</td>
    <td>
      <div>${fmt(o.t1272)} <span class="muted">(1.272)</span></div>
      <div>${fmt(o.t1618)} <span class="muted">(1.618)</span></div>
    </td>
    <td>
      <div class="${o.up1>0?'text-green-400':'text-gray-400'}">${pct(o.up1)}</div>
      <div class="${o.up2>0?'text-green-400':'text-gray-400'}">${pct(o.up2)}</div>
    </td>
    <td>$${fmt(o.stop)}</td>
    <td>
      <div class="${o.rr1>=2?'text-green-400':(o.rr1>=1?'text-yellow-400':'text-red-400')}">T1: ${fmt(o.rr1,2)}x</div>
      <div class="${o.rr2>=2?'text-green-400':(o.rr2>=1?'text-yellow-400':'text-red-400')}">T2: ${fmt(o.rr2,2)}x</div>
    </td>
    <td style="text-align:center">${sparkSVG(o.closes)}</td>
    <td><a class="btn" target="_blank" href="${tvLink(o.symbol)}">Ver</a></td>
  </tr>`;
}

function catHeaderHTML(cat, open=true){
  return `
  <tr class="cat-header ${open?'':'collapsed'}" data-cat="${cat}">
    <td colspan="13"><span class="arrow">â–¾</span> ${cat}</td>
  </tr>`;
}

async function render(){
  const tbody = document.getElementById("rows");

  // pintar cache si existe
  const cached = localStorage.getItem(CACHE_KEY);
  if(cached) tbody.innerHTML = cached;
  if(!cached) tbody.innerHTML = `<tr><td colspan="13" class="p-4 text-gray-400">Cargando datos...</td></tr>`;

  let html = "";

  for (const [cat, tokens] of Object.entries(CATEGORIES)) {
    html += catHeaderHTML(cat, true);

    const results = await Promise.allSettled(tokens.map(analyze));

    // Solo filas que pasaron los filtros
    const passed = results
      .filter(r => r.status==="fulfilled")
      .map(r => r.value)
      .sort((a,b)=> b.rank - a.rank);

    const rows = passed.map(rowHTML).join("");

    // Mensajes de depuraciÃ³n: errores â€œdurosâ€ de datos/API
    const apiErrors = results
      .filter(r => r.status==="rejected" && (String(r.reason).includes("HTTP") || String(r.reason).includes("data vacÃ­o") || String(r.reason).includes("insuficiente")))
      .map(r => `<tr class="border-b border-gray-800 text-red-400"><td colspan="13">Error de datos: ${r.reason?.message || r}</td></tr>`)
      .join("");

    // Resumen de tokens filtrados por reglas tÃ¡cticas
    const filteredCount = results.filter(r => r.status==="rejected" && String(r.reason).includes("Filtro:")).length;
    const filterSummary = `<tr class="border-b border-gray-800 text-yellow-400"><td colspan="13">${filteredCount} tokens filtrados (Upside ${MIN_UPSIDE}â€“${MAX_UPSIDE}% y/o RR â‰¥ ${MIN_RR}x no cumplidos).</td></tr>`;

    html += rows + filterSummary + apiErrors;
  }

  tbody.innerHTML = html;
  localStorage.setItem(CACHE_KEY, html);
  attachCollapsers();
  console.log("âœ… v6.0 actualizado:", new Date().toLocaleTimeString());

  setTimeout(render, REFRESH_INTERVAL);
}

/* Colapsar/expandir categorÃ­as */
function attachCollapsers(){
  const tbody = document.getElementById("rows");
  const headers = tbody.querySelectorAll(".cat-header");
  headers.forEach(h=>{
    h.addEventListener("click", ()=>{
      let row = h.nextElementSibling;
      const collapsed = h.classList.toggle("collapsed");
      while(row && !row.classList.contains("cat-header")){
        row.style.display = collapsed ? "none" : "";
        row = row.nextElementSibling;
      }
    });
    const arrow = h.querySelector(".arrow");
    if(arrow){ arrow.textContent = "â–¾"; }
  });
}

/* start */
render();
</script>

<p class="text-xs text-gray-500 mt-4 text-center">
v6.0 â€” Filtro tÃ¡ctico (Upside 10â€“40% y RR â‰¥ 2x), swing 21d, ranking con volumen, categorÃ­as colapsables, mensajes de depuraciÃ³n y cache local.  
No constituye asesoramiento financiero.
</p>
</body>
</html>
